---
---

<section class="preview" id="preview" aria-label="How Gitplum works">
  <!-- Circuit flow canvas background -->
  <canvas class="circuit-canvas" id="circuitCanvas" aria-hidden="true"></canvas>
  <div class="preview-inner">
    <div class="preview-text fade-in">
      <div class="section-label">// how_it_works</div>
      <h2>One question. <em>The full picture.</em></h2>
      <p>Your agent hits unfamiliar software. The kind where no README or Google search gives you what you need. Gitplum returns the architectural answer — with sources — in seconds.</p>
      <ul class="preview-list">
        <li>
          <svg width="20" height="20" fill="none" stroke="currentColor" stroke-width="2.5" viewBox="0 0 24 24" aria-hidden="true"><path stroke-linecap="round" stroke-linejoin="round" d="M5 13l4 4L19 7" /></svg>
          Deep architectural questions, answered with exact citations
        </li>
        <li>
          <svg width="20" height="20" fill="none" stroke="currentColor" stroke-width="2.5" viewBox="0 0 24 24" aria-hidden="true"><path stroke-linecap="round" stroke-linejoin="round" d="M5 13l4 4L19 7" /></svg>
          Pinpoints the specific files and line numbers
        </li>
        <li>
          <svg width="20" height="20" fill="none" stroke="currentColor" stroke-width="2.5" viewBox="0 0 24 24" aria-hidden="true"><path stroke-linecap="round" stroke-linejoin="round" d="M5 13l4 4L19 7" /></svg>
          Works on any public or private GitHub repository
        </li>
        <li>
          <svg width="20" height="20" fill="none" stroke="currentColor" stroke-width="2.5" viewBox="0 0 24 24" aria-hidden="true"><path stroke-linecap="round" stroke-linejoin="round" d="M5 13l4 4L19 7" /></svg>
          Compatible with every agent framework and model
        </li>
      </ul>
    </div>
    <div class="preview-code fade-in">
      <div class="terminal">
        <div class="terminal-header">
          <span class="terminal-dot"></span>
          <span class="terminal-dot"></span>
          <span class="terminal-dot"></span>
          <span class="terminal-title">gitplum ask — kubernetes/kubernetes</span>
        </div>
        <div class="terminal-body">
          <span class="t-muted">$</span> <span class="t-cmd">gitplum ask</span> kubernetes/kubernetes<br />
          <span class="t-white">"When a pod is evicted due to node memory</span><br />
          <span class="t-white">&nbsp;pressure, how does the kubelet decide</span><br />
          <span class="t-white">&nbsp;which pods to kill first?"</span><br /><br />
          <span class="t-muted">[resolving]</span> Analyzing kubernetes/kubernetes...<br /><br />
          <span class="t-green">&#10003;</span> <span class="t-white">The kubelet uses an eviction manager that ranks</span><br />
          <span class="t-white">&nbsp;&nbsp;pods by QoS class (BestEffort → Burstable →</span><br />
          <span class="t-white">&nbsp;&nbsp;Guaranteed), then by memory usage relative to</span><br />
          <span class="t-white">&nbsp;&nbsp;their requests. BestEffort pods exceeding usage</span><br />
          <span class="t-white">&nbsp;&nbsp;are evicted first.</span><br /><br />
          <span class="t-muted">[source]</span> <span class="t-plum">pkg/kubelet/eviction/helpers.go:214</span><br />
          <span class="t-muted">[source]</span> <span class="t-plum">pkg/kubelet/eviction/eviction_manager.go:387</span>
        </div>
      </div>
    </div>
  </div>
</section>

<style>
  .preview {
    padding: 120px 24px;
    max-width: 1200px;
    margin: 0 auto;
    position: relative;
    overflow: hidden;
  }

  /* ── Circuit Flow Canvas ── */
  .circuit-canvas {
    position: absolute;
    inset: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
    z-index: 0;
  }

  .preview-inner {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 80px;
    align-items: center;
    position: relative;
    z-index: 1;
  }

  .preview-text h2 {
    font-family: var(--sans);
    font-size: clamp(1.75rem, 4vw, 2.5rem);
    font-weight: 800;
    font-style: normal;
    letter-spacing: -0.02em;
    margin-bottom: 16px;
  }

  .preview-text h2 em {
    font-family: var(--display);
    font-weight: 400;
    font-style: italic;
    color: var(--plum);
  }

  .preview-text p {
    font-size: 1.063rem;
    color: var(--text-secondary);
    line-height: 1.7;
    margin-bottom: 32px;
  }

  .preview-list {
    list-style: none;
    display: flex;
    flex-direction: column;
    gap: 14px;
  }

  .preview-list li {
    display: flex;
    align-items: flex-start;
    gap: 12px;
    font-size: 0.975rem;
    color: var(--text);
    font-weight: 500;
  }

  .preview-list li svg {
    flex-shrink: 0;
    color: var(--plum);
    margin-top: 2px;
  }

  .preview-code pre {
    margin: 0;
    white-space: pre;
  }

  .preview-code code {
    font-family: var(--mono);
    font-size: 0.813rem;
    line-height: 1.9;
  }

  .t-cmd { color: #fff; font-weight: 600; }
  .t-plum { color: #C084FC; }
  .t-green { color: #4ADE80; }
  .t-white { color: #E4E4E7; }
  .t-muted { color: #52525B; }

  @media (max-width: 900px) {
    .preview-inner {
      grid-template-columns: 1fr;
      gap: 48px;
    }

    .preview-code {
      order: -1;
    }
  }
</style>

<script>
  // Neural network: drifting nodes that connect when near each other
  (function initNeural() {
    const canvas = document.getElementById('circuitCanvas') as HTMLCanvasElement;
    if (!canvas) return;
    const ctx = canvas.getContext('2d');
    if (!ctx) return;
    const prefersReduced = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
    if (prefersReduced) return;

    const dpr = Math.min(window.devicePixelRatio || 1, 2);
    let w: number, h: number;

    function resize() {
      const rect = canvas.getBoundingClientRect();
      w = rect.width;
      h = rect.height;
      canvas.width = w * dpr;
      canvas.height = h * dpr;
      ctx!.setTransform(dpr, 0, 0, dpr, 0, 0);
    }
    resize();
    window.addEventListener('resize', resize);

    interface Neuron {
      x: number; y: number;
      vx: number; vy: number;
      radius: number;
      pulsePhase: number;
      pulseSpeed: number;
    }

    const connectionDist = 160;
    const nodeCount = 40;
    const neurons: Neuron[] = [];

    for (let i = 0; i < nodeCount; i++) {
      neurons.push({
        x: Math.random() * w,
        y: Math.random() * h,
        vx: (Math.random() - 0.5) * 0.4,
        vy: (Math.random() - 0.5) * 0.4,
        radius: 1.5 + Math.random() * 1.5,
        pulsePhase: Math.random() * Math.PI * 2,
        pulseSpeed: 0.5 + Math.random() * 0.8,
      });
    }

    // Traveling pulses along active connections
    interface Pulse {
      from: number; to: number;
      t: number; speed: number;
    }
    const pulses: Pulse[] = [];

    let time = 0;
    let animId: number;

    function draw() {
      time += 0.016;
      ctx!.clearRect(0, 0, w, h);

      // Move neurons
      for (const n of neurons) {
        n.x += n.vx;
        n.y += n.vy;
        // Bounce off edges with padding
        if (n.x < -30) n.vx = Math.abs(n.vx);
        if (n.x > w + 30) n.vx = -Math.abs(n.vx);
        if (n.y < -30) n.vy = Math.abs(n.vy);
        if (n.y > h + 30) n.vy = -Math.abs(n.vy);
      }

      // Draw connections between nearby neurons
      for (let i = 0; i < neurons.length; i++) {
        for (let j = i + 1; j < neurons.length; j++) {
          const a = neurons[i], b = neurons[j];
          const dx = a.x - b.x, dy = a.y - b.y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          if (dist < connectionDist) {
            const alpha = (1 - dist / connectionDist) * 0.08;
            ctx!.strokeStyle = `rgba(139, 77, 171, ${alpha})`;
            ctx!.lineWidth = 0.6;
            ctx!.beginPath();
            ctx!.moveTo(a.x, a.y);
            ctx!.lineTo(b.x, b.y);
            ctx!.stroke();
          }
        }
      }

      // Draw neurons
      for (const n of neurons) {
        const pulse = 0.5 + 0.5 * Math.sin(time * n.pulseSpeed + n.pulsePhase);
        const alpha = 0.06 + 0.06 * pulse;

        // Outer glow
        const grad = ctx!.createRadialGradient(n.x, n.y, 0, n.x, n.y, n.radius * 5);
        grad.addColorStop(0, `rgba(192, 132, 252, ${alpha * 0.5})`);
        grad.addColorStop(1, 'rgba(192, 132, 252, 0)');
        ctx!.fillStyle = grad;
        ctx!.beginPath();
        ctx!.arc(n.x, n.y, n.radius * 5, 0, Math.PI * 2);
        ctx!.fill();

        // Core
        ctx!.beginPath();
        ctx!.arc(n.x, n.y, n.radius, 0, Math.PI * 2);
        ctx!.fillStyle = `rgba(139, 77, 171, ${alpha * 1.5})`;
        ctx!.fill();
      }

      // Spawn pulses occasionally
      if (Math.random() < 0.04 && pulses.length < 8) {
        const i = Math.floor(Math.random() * neurons.length);
        // Find a nearby neuron
        for (let j = 0; j < neurons.length; j++) {
          if (j === i) continue;
          const dx = neurons[i].x - neurons[j].x;
          const dy = neurons[i].y - neurons[j].y;
          if (Math.sqrt(dx * dx + dy * dy) < connectionDist) {
            pulses.push({ from: i, to: j, t: 0, speed: 0.015 + Math.random() * 0.02 });
            break;
          }
        }
      }

      // Draw pulses
      for (let p = pulses.length - 1; p >= 0; p--) {
        const pulse = pulses[p];
        pulse.t += pulse.speed;
        if (pulse.t >= 1) { pulses.splice(p, 1); continue; }

        const a = neurons[pulse.from], b = neurons[pulse.to];
        const px = a.x + (b.x - a.x) * pulse.t;
        const py = a.y + (b.y - a.y) * pulse.t;
        const glow = Math.sin(pulse.t * Math.PI);

        // Pulse glow
        const g = ctx!.createRadialGradient(px, py, 0, px, py, 6);
        g.addColorStop(0, `rgba(192, 132, 252, ${glow * 0.2})`);
        g.addColorStop(1, 'rgba(192, 132, 252, 0)');
        ctx!.fillStyle = g;
        ctx!.beginPath();
        ctx!.arc(px, py, 6, 0, Math.PI * 2);
        ctx!.fill();

        // Bright core
        ctx!.beginPath();
        ctx!.arc(px, py, 1.5, 0, Math.PI * 2);
        ctx!.fillStyle = `rgba(255, 255, 255, ${glow * 0.3})`;
        ctx!.fill();
      }

      animId = requestAnimationFrame(draw);
    }

    const observer = new IntersectionObserver((entries) => {
      if (entries[0].isIntersecting) {
        animId = requestAnimationFrame(draw);
      } else {
        cancelAnimationFrame(animId);
      }
    }, { threshold: 0.05 });
    observer.observe(canvas);

    window.addEventListener('resize', () => {
      resize();
      // Reposition neurons within new bounds
      for (const n of neurons) {
        n.x = Math.min(n.x, w);
        n.y = Math.min(n.y, h);
      }
    });
  })();
</script>
