---
const targets = [
  { category: 'Systems', repos: ['Linux', 'Darwin', 'Windows Kernel'], status: 'indexing' },
  { category: 'Engines', repos: ['V8', 'Gecko', 'Godot', 'Unreal'], status: 'indexing' },
  { category: 'Orchestration', repos: ['Kubernetes', 'Docker', 'Terraform'], status: 'indexing' },
  { category: 'AI / ML', repos: ['PyTorch', 'TensorFlow', 'Llama.cpp'], status: 'indexing' },
];
---

<section class="index-section" id="index" aria-label="Deep-indexed repositories">
  <!-- Mathematical shapes background -->
  <canvas class="geo-canvas" id="geoCanvas" aria-hidden="true"></canvas>
  <div class="index-inner">
    <div class="index-content fade-in">
      <div class="section-label">// the_index</div>
      <h2>Deep context for <em>the hardest software on earth.</em></h2>
      <p>Gitplum is deep-indexing the most complex software. When your agent encounters these repos, the knowledge base delivers a deep understanding — not a surface scan.</p>
    </div>
    <div class="index-grid fade-in">
      {targets.map(({ category, repos }) => (
        <article class="index-card">
          <h3>{category}</h3>
          <ul>
            {repos.map(repo => (
              <li>
                <span class="dot"></span>
                {repo}
              </li>
            ))}
          </ul>
        </article>
      ))}
    </div>
  </div>
</section>

<style>
  .index-section {
    padding: 120px 24px;
    background: var(--surface-alt);
    position: relative;
    overflow: hidden;
  }

  /* Smooth top and bottom edges */
  .index-section::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    height: 80px;
    background: linear-gradient(to bottom, var(--white) 0%, transparent 100%);
    pointer-events: none;
    z-index: 2;
  }

  .index-section::after {
    content: '';
    position: absolute;
    bottom: 0;
    left: 0;
    right: 0;
    height: 80px;
    background: linear-gradient(to top, var(--white) 0%, transparent 100%);
    pointer-events: none;
    z-index: 2;
  }

  /* ── Geometric Canvas ── */
  .geo-canvas {
    position: absolute;
    inset: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
    z-index: 0;
  }

  .index-inner {
    max-width: 1200px;
    margin: 0 auto;
    position: relative;
    z-index: 1;
  }

  .index-content {
    text-align: center;
    margin-bottom: 64px;
  }

  .index-content h2 {
    font-family: var(--sans);
    font-size: clamp(1.75rem, 4vw, 2.5rem);
    font-weight: 800;
    font-style: normal;
    letter-spacing: -0.02em;
    margin-bottom: 16px;
  }

  .index-content h2 em {
    font-family: var(--display);
    font-weight: 400;
    font-style: italic;
    color: var(--plum);
  }

  .index-content p {
    font-size: 1.125rem;
    color: var(--text-secondary);
    max-width: 640px;
    margin: 0 auto;
    line-height: 1.7;
  }

  .index-grid {
    display: grid;
    grid-template-columns: repeat(4, 1fr);
    gap: 20px;
  }

  .index-card {
    background: var(--white);
    border: 1px solid var(--border);
    border-radius: var(--radius-lg);
    padding: 28px 24px;
    transition: all 0.35s cubic-bezier(0.4, 0, 0.2, 1);
  }

  .index-card:hover {
    border-color: var(--plum-light);
    box-shadow: var(--shadow-md);
    transform: translateY(-3px);
  }

  h3 {
    font-family: var(--mono);
    font-size: 0.75rem;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.12em;
    color: var(--plum);
    margin-bottom: 16px;
  }

  ul {
    list-style: none;
    display: flex;
    flex-direction: column;
    gap: 10px;
  }

  li {
    display: flex;
    align-items: center;
    gap: 10px;
    font-size: 0.938rem;
    color: var(--text);
    font-weight: 500;
  }

  .dot {
    width: 7px;
    height: 7px;
    border-radius: 50%;
    background: var(--plum-light);
    flex-shrink: 0;
    box-shadow: 0 0 6px rgba(139, 77, 171, 0.3);
  }

  @media (max-width: 900px) {
    .index-grid {
      grid-template-columns: repeat(2, 1fr);
    }
  }

  @media (max-width: 540px) {
    .index-grid {
      grid-template-columns: 1fr;
      max-width: 400px;
      margin: 0 auto;
    }
  }
</style>

<script>
  // 3D wireframe polyhedra (icosahedrons, dodecahedrons, tesseracts)
  (function() {
    const prefersReduced = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
    if (prefersReduced) return;

    const canvas = document.getElementById('geoCanvas') as HTMLCanvasElement;
    if (!canvas) return;
    const ctx = canvas.getContext('2d');
    if (!ctx) return;

    let w: number, h: number;
    const dpr = Math.min(window.devicePixelRatio || 1, 2);

    type V3 = [number, number, number];
    type V4 = [number, number, number, number];

    // --- Polyhedra vertex generators ---
    function icosahedronVerts(): V3[] {
      const t = (1 + Math.sqrt(5)) / 2;
      const v: V3[] = [
        [-1, t, 0],[1, t, 0],[-1,-t, 0],[1,-t, 0],
        [0,-1, t],[0, 1, t],[0,-1,-t],[0, 1,-t],
        [t, 0,-1],[t, 0, 1],[-t, 0,-1],[-t, 0, 1],
      ];
      const len = Math.sqrt(1 + t * t);
      return v.map(([x,y,z]) => [x/len, y/len, z/len]);
    }

    function icosahedronEdges(): [number,number][] {
      const verts = icosahedronVerts();
      const edges: [number,number][] = [];
      for (let i = 0; i < verts.length; i++) {
        for (let j = i+1; j < verts.length; j++) {
          const dx = verts[i][0]-verts[j][0], dy = verts[i][1]-verts[j][1], dz = verts[i][2]-verts[j][2];
          const d = Math.sqrt(dx*dx+dy*dy+dz*dz);
          if (d < 0.75) edges.push([i,j]);
        }
      }
      return edges;
    }

    function dodecahedronVerts(): V3[] {
      const t = (1 + Math.sqrt(5)) / 2;
      const it = 1/t;
      const v: V3[] = [
        [1,1,1],[1,1,-1],[1,-1,1],[1,-1,-1],
        [-1,1,1],[-1,1,-1],[-1,-1,1],[-1,-1,-1],
        [0,it,t],[0,it,-t],[0,-it,t],[0,-it,-t],
        [it,t,0],[it,-t,0],[-it,t,0],[-it,-t,0],
        [t,0,it],[t,0,-it],[-t,0,it],[-t,0,-it],
      ];
      const len = Math.sqrt(3);
      return v.map(([x,y,z]) => [x/len, y/len, z/len]);
    }

    function dodecahedronEdges(): [number,number][] {
      const verts = dodecahedronVerts();
      const edges: [number,number][] = [];
      for (let i = 0; i < verts.length; i++) {
        for (let j = i+1; j < verts.length; j++) {
          const dx = verts[i][0]-verts[j][0], dy = verts[i][1]-verts[j][1], dz = verts[i][2]-verts[j][2];
          const d = Math.sqrt(dx*dx+dy*dy+dz*dz);
          if (d < 0.55) edges.push([i,j]);
        }
      }
      return edges;
    }

    function tesseractVerts(): V4[] {
      const v: V4[] = [];
      for (let i = 0; i < 16; i++) {
        v.push([
          (i & 1) ? 1 : -1,
          (i & 2) ? 1 : -1,
          (i & 4) ? 1 : -1,
          (i & 8) ? 1 : -1,
        ]);
      }
      return v;
    }

    function tesseractEdges(): [number,number][] {
      const edges: [number,number][] = [];
      for (let i = 0; i < 16; i++) {
        for (let j = i+1; j < 16; j++) {
          // Connected if differ in exactly 1 bit
          const xor = i ^ j;
          if (xor && (xor & (xor - 1)) === 0) edges.push([i,j]);
        }
      }
      return edges;
    }

    // Project 4D -> 3D (stereographic-ish)
    function project4to3(v: V4, angle: number): V3 {
      const cosW = Math.cos(angle), sinW = Math.sin(angle);
      const w2 = v[3] * cosW - v[2] * sinW;
      const z2 = v[2] * cosW + v[3] * sinW;
      const scale = 2 / (2.5 - w2 * 0.4);
      return [v[0] * scale, v[1] * scale, z2 * scale];
    }

    // Rotate 3D point
    function rotate3(v: V3, rx: number, ry: number, rz: number): V3 {
      let [x, y, z] = v;
      // Rotate X
      let c = Math.cos(rx), s = Math.sin(rx);
      let ny = y*c - z*s, nz = y*s + z*c;
      y = ny; z = nz;
      // Rotate Y
      c = Math.cos(ry); s = Math.sin(ry);
      let nx = x*c + z*s;
      nz = -x*s + z*c;
      x = nx; z = nz;
      // Rotate Z
      c = Math.cos(rz); s = Math.sin(rz);
      nx = x*c - y*s;
      ny = x*s + y*c;
      return [nx, ny, z];
    }

    // Project 3D -> 2D
    function project3to2(v: V3, scale: number): [number, number, number] {
      const perspective = 3;
      const s = perspective / (perspective + v[2]);
      return [v[0] * scale * s, v[1] * scale * s, s];
    }

    interface Polyhedron {
      cx: number; cy: number; scale: number; alpha: number;
      rx: number; ry: number; rz: number;
      rxS: number; ryS: number; rzS: number;
      type: 'ico' | 'dodec' | 'tess';
      verts3: V3[]; edges: [number, number][];
      verts4?: V4[];
      wAngle?: number; wSpeed?: number;
      particles: { edgeIdx: number; t: number; speed: number; }[];
    }

    let shapes: Polyhedron[] = [];

    const icoVerts = icosahedronVerts();
    const icoEdges = icosahedronEdges();
    const dodVerts = dodecahedronVerts();
    const dodEdges = dodecahedronEdges();
    const tessVerts4 = tesseractVerts();
    const tessEdges = tesseractEdges();

    function resize() {
      const rect = canvas.parentElement!.getBoundingClientRect();
      w = rect.width;
      h = rect.height;
      canvas.width = w * dpr;
      canvas.height = h * dpr;
      canvas.style.width = w + 'px';
      canvas.style.height = h + 'px';
      ctx!.setTransform(dpr, 0, 0, dpr, 0, 0);
    }

    function createShapes() {
      shapes = [];
      const configs: {
        x: number; y: number; scale: number; alpha: number;
        rxS: number; ryS: number; rzS: number;
        type: 'ico' | 'dodec' | 'tess';
      }[] = [
        { x: 0.02, y: 0.10, scale: 280, alpha: 0.10, rxS: 0.004, ryS: 0.006, rzS: 0.002, type: 'ico' },
        { x: 0.98, y: 0.12, scale: 260, alpha: 0.10, rxS:-0.005, ryS: 0.003, rzS:-0.004, type: 'tess' },
        { x: 0.01, y: 0.85, scale: 240, alpha: 0.08, rxS: 0.006, ryS:-0.004, rzS: 0.003, type: 'dodec' },
        { x: 0.99, y: 0.88, scale: 260, alpha: 0.08, rxS:-0.003, ryS: 0.005, rzS:-0.002, type: 'ico' },
        { x: 0.02, y: 0.48, scale: 220, alpha: 0.08, rxS: 0.005, ryS:-0.003, rzS: 0.005, type: 'tess' },
        { x: 0.98, y: 0.5,  scale: 230, alpha: 0.08, rxS:-0.004, ryS: 0.004, rzS:-0.003, type: 'dodec' },
      ];

      for (const c of configs) {
        let verts3: V3[] = [];
        let edges: [number, number][] = [];
        let verts4: V4[] | undefined;
        let wAngle: number | undefined;
        let wSpeed: number | undefined;

        if (c.type === 'ico') { verts3 = icoVerts; edges = icoEdges; }
        else if (c.type === 'dodec') { verts3 = dodVerts; edges = dodEdges; }
        else { verts4 = tessVerts4; edges = tessEdges; wAngle = 0; wSpeed = 0.008; }

        const particles: { edgeIdx: number; t: number; speed: number; }[] = [];
        const pCount = 3 + Math.floor(Math.random() * 4);
        for (let i = 0; i < pCount; i++) {
          particles.push({
            edgeIdx: Math.floor(Math.random() * edges.length),
            t: Math.random(),
            speed: 0.005 + Math.random() * 0.012,
          });
        }

        shapes.push({
          cx: c.x * w, cy: c.y * h, scale: c.scale, alpha: c.alpha,
          rx: Math.random() * Math.PI * 2,
          ry: Math.random() * Math.PI * 2,
          rz: Math.random() * Math.PI * 2,
          rxS: c.rxS, ryS: c.ryS, rzS: c.rzS,
          type: c.type,
          verts3, edges, verts4, wAngle, wSpeed,
          particles,
        });
      }
    }

    function draw() {
      ctx!.clearRect(0, 0, w, h);

      for (const s of shapes) {
        if (!s || !s.edges || !Array.isArray(s.edges)) continue;
        s.rx += s.rxS;
        s.ry += s.ryS;
        s.rz += s.rzS;

        // Get projected 2D vertices
        let projected: [number, number, number][] = [];

        if (s.type === 'tess' && s.verts4) {
          s.wAngle = (s.wAngle || 0) + (s.wSpeed || 0);
          const v3 = s.verts4.map(v => project4to3(v, s.wAngle!));
          projected = v3.map(v => {
            const rotated = rotate3(v, s.rx, s.ry, s.rz);
            return project3to2(rotated, s.scale);
          });
        } else {
          projected = s.verts3.map(v => {
            const rotated = rotate3(v, s.rx, s.ry, s.rz);
            return project3to2(rotated, s.scale);
          });
        }

        // Draw edges
        if (projected.length === 0 || !s.edges || s.edges.length === 0) continue;
        for (let e = 0; e < s.edges.length; e++) {
          const edge = s.edges[e];
          if (!edge) continue;
          const a = projected[edge[0]], b = projected[edge[1]];
          if (!a || !b) continue;
          const depth = (a[2] + b[2]) / 2;
          const edgeAlpha = s.alpha * Math.max(0.3, Math.min(1, depth));
          ctx!.beginPath();
          ctx!.moveTo(s.cx + a[0], s.cy + a[1]);
          ctx!.lineTo(s.cx + b[0], s.cy + b[1]);
          ctx!.strokeStyle = `rgba(139, 77, 171, ${edgeAlpha})`;
          ctx!.lineWidth = 0.8;
          ctx!.stroke();
        }

        // Draw vertex dots
        for (const p of projected) {
          const dotAlpha = s.alpha * 1.8 * Math.max(0.4, Math.min(1, p[2]));
          ctx!.beginPath();
          ctx!.arc(s.cx + p[0], s.cy + p[1], 1.5 * p[2], 0, Math.PI * 2);
          ctx!.fillStyle = `rgba(192, 132, 252, ${dotAlpha})`;
          ctx!.fill();
        }

        // Particles traveling along edges
        for (const p of s.particles) {
          p.t += p.speed;
          if (p.t > 1) {
            p.t = 0;
            p.edgeIdx = Math.floor(Math.random() * s.edges.length);
          }
          if (!s.edges || p.edgeIdx >= s.edges.length) continue;
          const edge = s.edges[p.edgeIdx];
          if (!edge) continue;
          const ei = edge[0], ej = edge[1];
          const a = projected[ei], b = projected[ej];
          if (!a || !b) continue;
          const px = a[0] + (b[0] - a[0]) * p.t;
          const py = a[1] + (b[1] - a[1]) * p.t;
          const glow = Math.sin(p.t * Math.PI);

          ctx!.beginPath();
          ctx!.arc(s.cx + px, s.cy + py, 2, 0, Math.PI * 2);
          ctx!.fillStyle = `rgba(192, 132, 252, ${glow * 0.6})`;
          ctx!.fill();

          ctx!.beginPath();
          ctx!.arc(s.cx + px, s.cy + py, 6, 0, Math.PI * 2);
          ctx!.fillStyle = `rgba(192, 132, 252, ${glow * 0.1})`;
          ctx!.fill();
        }
      }

      requestAnimationFrame(draw);
    }

    function init() {
      resize();
      if (w === 0 || h === 0) {
        requestAnimationFrame(init);
        return;
      }
      createShapes();
      draw();
    }

    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', init);
    } else {
      requestAnimationFrame(init);
    }
    window.addEventListener('resize', () => {
      resize();
      if (w > 0 && h > 0) createShapes();
    });
  })();
</script>
